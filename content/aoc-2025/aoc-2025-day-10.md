+++
title = "Advent of Code 2025 Day 10— Rust"
date = 2025-12-10T05:00:00+00:00
weight = 2503
+++

## Marketing Pitch and Impressions

> *Rust*
>
> *A language empowering everyone to build reliable and efficient software.*
>
> *— [rust-lang.org](https://rust-lang.org/)*

A somewhat understated soundbite briefly covering Rust's impact on the software
industry.

Rust is currently a highly favored systems programming language, a position it
has earned to a significant degree.  In my view, its significant popularity can
sometimes lead to its selection in scenarios where other languages might be a
more productive choice.  Perhaps similar but orthogonal to the position that
Python enjoys.

Visual Studio Code support for Rust is great.  I hear RustRover from JetBrains
is excellent, but I have not used it.

## The Code

Not my favourite solution this year.  Usually I try to make solutions
stand-alone using only standard libraries for whatever language I'm using.
Unfortunately that did not happen for this problem.

For part 1 I used BFS to find the solution while I was still labouring under the
misapprehension that I would be able to solve the problem without using external
libraries.  It's not efficient, but Rust's execution speed does a great job of
wallpapering over the algorithmic issues.  Part 1 is a search over GF(2) for the
number of button presses, so the search space is limited.

For part 2 it was pretty obvious that the search space is now many orders of
magnitude larger and BFS wasn't going to work.  Considering how much time I
believed it would take me to write a solver (plus resolve any quirks with
under/over-constrained problems and non-integer solutions in the set) compared
to how much time I had before my workday started, I basically caved, and started
looking for a Rust ILP solver.

It turns out that if you type "Rust ILP solver" into Google, the first solver
that comes up is [`good_lp`](https://github.com/rust-or/good_lp).  I just went
with the `microlp` feature as it looked good enough and did not require any
additional dependencies.

For the solver problem, we have integer $X_i, X_i \ge 0$ representing the
number of button presses for each button.  We want to minimise $\sum{X_i}$.
Next we add the constraints for joltage summing to the number of button presses.

Fortunately, the following day
[u/tenthmascot](https://www.reddit.com/user/tenthmascot/) posted a
[great solution](https://www.reddit.com/r/adventofcode/comments/1pk87hl/2025_day_10_part_2_bifurcate_your_way_to_victory/)
on Reddit that I have implemented in [Day 10 Redux— Kotlin](../aoc-2025-day-10-redux/).
The implemented solution meets my self-imposed and completely arbitrary requirements
for being both stand-alone and fewer than 100 lines long!

{{% code file="code-aoc-2025/d10/src/main.rs" language="rust" %}}

## Install Rust and run

The recommended way to install Rust is via rustup, but your package manager
probably has installable packages.

```sh
# I installed from Homebrew
brew install rust

# rust-lang.org recommends using rustup
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Execute the code
cd d10 && cargo run
```

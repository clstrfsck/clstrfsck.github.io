+++
title = "Advent of Code 2025 Day 2— Julia"
date = 2025-12-02T05:00:00+00:00
weight = 2511
+++

The Julia Github repo has this to say about the language:

> *Julia is a high-level, high-performance dynamic language for technical*
> *computing.*
>
> *— [github.com/JuliaLang/julia](https://github.com/JuliaLang/julia)*

The website further elaborates on Julia's key features:

> ***Fast:*** *Julia was designed for high performance.  Julia programs*
> *automatically compile to efficient native code via LLVM, and support*
> *multiple platforms.*
>
> ***Dynamic:*** *Julia is dynamically typed, feels like a scripting* *language,
> and has good support for interactive use, but can also* *optionally be
> separately compiled.*
>
> ***Reproducible:*** *Reproducible environments make it possible to* *recreate
> the same Julia environment every time, across platforms, with* *pre-built
> binaries.*
>
> ***Composable:*** *Julia uses multiple dispatch as a paradigm, making it*
> *easy to express many object-oriented and functional programming patterns.*
> *The talk on the Unreasonable Effectiveness of Multiple Dispatch explains*
> *why it works so well.*
>
> ***General:*** *Julia provides asynchronous I/O, metaprogramming,* *debugging,
> logging, profiling, a package manager, and the ability to* *build binaries.*
>
> ***Open source:*** *Julia is an open source project with over 1,000*
> *contributors.  It is made available under the MIT license.  The source* *code
> is available on GitHub.  Julia has a welcoming community accessible* *to all
> backgrounds.*
>
> *— [julialang.org](https://julialang.org/)*

Like many languages focussed on numerical computing, Julia has 1-based array
indexing.  I don't think this is a major issue, but I imagine it would be
something that would occasionaly trip up folks coming from 0-based languages
while they adjust.

Visual Studio Code support for Julia is excellent.

## The Code

One interesting feature is the use of Unicode operators.  While using the ÷
symbol for integer division looks neat, it presents a visual tripping hazard,
and at a quick glance, `n÷2+1` looks suspiciously similar to `n+2+1` in
`equal_halves(…)`.  For those on Macs, you can type `÷` directly with
`Option-/`.

Unicode quirks aside, the code is clean and pretty easy to read.  The standard
libraries seem complete and accessible.  Arrays / vectors are column-major,
hence the use of `vcat` in the `mapreduce` call.

The approach is pretty straightforward.  The code produces a gigantic list of
numbers, nearly 20 million of them.  For part 1, we just check straightforwardly
whether the length is even and the two halves match.

For part 2, I originally used a regular expression in Kotlin to initially solve
the problem.  It turns out that backtracking regexes are much slower in Julia
than they are in Kotlin— I assume the underlying Java libraries have some
optimisations for specific cases that improved the performance for the regexes I
used.

Fortunately, many posts in the reddit solutions code pointed out that a string
consists of a repeated substring if it is a nontrivial rotation of itself, and
that is the algorithm implemented here.

{{% code file="code-aoc-2025/d02.jl" language="julia" %}}

## Install Julia and run

The modern way to manage Julia versions is `juliaup`.  Regular package managers
work fine too.

```sh
# I installed via Homebrew
brew install julia

# Website recommends running random scripts on your machine
curl -fsSL https://install.julialang.org | sh

# Execute the code
julia d02.jl
```

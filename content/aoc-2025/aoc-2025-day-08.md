+++
title = "Advent of Code 2025 Day 8— Go"
date = 2025-12-08T05:00:00+00:00
weight = 2505
+++

## Marketing Pitch and Impressions

> *Build simple, secure, scalable systems with Go*
>
> - *An open-source programming language supported by Google*
> - *Easy to learn and great for teams*
> - *Built-in concurrency and a robust standard library*
> - *Large ecosystem of partners, communities, and tools*
>
> *— [go.dev](https://go.dev/)*

In my view, Go (aka Golang if you want to google something), is a great language
for folks that value getting stuff done.  The language designers have made a
language that has deliberately kept the core set of functionality and keywords
small and opinionated.  For example, there are no `public` or `private` or even
`protected` keywords in Go.  Public declarations start with a capital letter (eg
`PublicFunction()`), and non-public declarations do not (eg
`nonPublicFunction()`).

Some of this convention and uniformity can be a bit grating initially for folks
like me that prefer to exercise some control over code layout.  For example in
Visual Studio Code, upon saving a source file it is automatically reformatted.
Using tabs, no less.  I presume this can be turned off or customised, but it all
seems to be part of a larger, apparently successful plan to make folks more
productive in the language.

Visual Studio Code support for Go is excellent.  Tooling is excellent.
Everything is fast and smooth.

## The Code

I really like Go.  The syntax is easy to read, the tooling is excellent, and the
available ecosystem is huge.  One possible drawback is that simplicity seems to
come at a cost of expressiveness and conciseness.  This is the largest number of
lines of code in all the solutions— for comparison, an equivalent Kotlin
implementation for this is around 50 lines, almost half of the code.

For this puzzle, the two major elements we use are a list of possible
connections sorted by length, and a union-find disjoint set of junction boxes.

For part 1, we join up the 1,000 closest junctions and then query the disjoint
set for the largest members and multiply them.

For part 2, we use Kruskal's algorithm: keep connecting junctions in distance
order, until the disjoint set has size 1.  We then compute the product of the
two `x` coordinates of the last connected edge.

{{% code file="code-aoc-2025/d08.go" language="go" %}}

## Install Go and run

You can download installers and whatnot from the [go.dev](https://go.dev/dl/)
website, but installing via your package manager is probably going to be easier
over time.

```sh
# I installed via Homebrew
brew install golang

# Download from the website if you must
# https://go.dev/dl/

# Execute the code
go run d08.go
```

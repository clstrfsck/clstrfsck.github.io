+++
title = "Advent of Code 2025 Day 11— Haskell"
date = 2025-12-11T05:00:00+00:00
weight = 2502
+++

## Marketing Pitch and Impressions

> *Why Haskell?*
>
> - *A new paradigm*
> - *Composition and predictability*
> - *Declarative*
> - *Performance*
> - *Abstraction*
> - *Excellent tooling*
>
> *— [haskell.org](https://www.haskell.org/) (abridged)*

I started with Swift, but I couldn't resist rewriting the solution in Haskell.
This problem is practically tailor-made to showcase the benefits of non-strict
evaluation.

Visual Studio Code support for Haskell is excellent.

## The Code

We define a map `memo`, populated with all possible nodes and flag values.  The
values in `memo` are unevaluated calls to `count`.  `count` is then defined to
look up the values it needs in `memo`.

Assuming we don't have any cycles in the graph, this will eventually terminate.

The lazy evaluation in Haskell means that while this looks a bit like top-down
dynamic programming, it is a bottom up strategy as the entire (unevaluated)
solution space is constructed up front, and then just the relevant parts
evaluated for the solutions we need.

Both part 1 and part 2 are evaluated using the same code, just modifying the
start node and flags to suit.

{{% code file="code-aoc-2025/d11.hs" language="haskell" %}}

## Install GHC and run

The recommended way to install Haskell is via GHCup, but your package manager
probably has installable packages.

```sh
# I installed from Homebrew
brew install ghc

# haskell.org recommends using GHCup
curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh

# Execute the code
runhaskell d11.hs
```
